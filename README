Project's home: http://www.hexstreamsoft.com/projects/positional-lambda/


positional-lambda is a concise, intuitive and flexible syntax (macro)
for trivial lambdas that eschews explicit (and often
contextually-redundant) naming of parameter variables in favor of
positional references, with support for a used or ignored &rest
parameter and automatic declaration of ignored parameters when logical
"gaps" are left in the positional references.

LIFT is particularly useful when used in conjunction with mapping
operators such as MAPCAR, though for brevity the mapping parts will
not be shown in these examples, only the LIFT expressions and
equivalent LAMBDA's.

(lift (values :3 :1))
==
(lambda (first second third)
  (declare (ignore second))
  (values third first))

(lift &rest rest (list* :2 :1 rest))
==
(lambda (first second &rest rest)
  (list* second first rest))

(lift &rest nil (list :2 :1))
==
(lambda (first second &rest rest)
  (declare (ignore rest))
  (list second first))


It's possible to specify a minimum number of required arguments:

(lift :3 :2)
==
(lambda (first second third)
  (declare (ignore first third))
  second)

(lift :2 :3) ; redundant minimum: 3 > 2.
==
(lift :3)


Which also has the effect of "pushing back" the &rest argument if there's one:

(lift :3 &rest rest (mapcar :1 rest))
==
(lambda (first second third &rest rest)
  (declare (ignore second third))
  (mapcar first rest))


The first argument to LIFT is treated as a specification of the
minimum number of arguments only if it looks like a positional reference
and LIFT was invoked with other arguments:

(lift :2)
==
(lambda (first second)
  (declare (ignore first))
  second)


LIFT accepts an implicit PROGN, not just one expression:

(lift (print :1) :2)
==
(lambda (first second)
  (print first)
  second)


Also, LIFT's :let "local special operator" allows one to "lift" parts of
its body outside the lambda to a LET without needing to name and then
refer to an explicit variable.

(lift :2 (list :1 (:let (random))))
==
(let ((number (random)))
  (lambda (first second)
    (declare (ignore second))
    (list first number)))


Another feature is :once, which is like :let except it computes the
associated form in its original lexical and dynamic context within the
lambda the first time its evaluation completes and returns the cached
value on subsequent evaluations.

(lift (write :1 :base (:once *print-base*)))
==
(let (base basep)
  (lambda (first)
    (write first :base (if basep
                           base
                           (prog1 (setf base *print-base*)
                             (setf basep t))))))

It is an error to nest the :let and :once local special operators
within themselves or eachother:

(lift (:let (:let 1))) ; error

Beware that LIFT's parsing model, described below, can result in
"false matches" for :let and :once:

(lift (member :1 '(:let :let*))) ; won't do the right thing.

(lift (member :1 '(:let* :let))) ; will do the right thing.

It would be possible to disable matching of :let and :some in quoted
expressions, but this could theoretically adversely affect the
semantics of some macros and leave other kinds of false matches
anyway, so simplicity was chosen.


To use lambda-lift, simply (:import-from #:lambda-lift #:lift) from
your DEFPACKAGE. Don't (:use #:lambda-lift)! "Clashy" symbols might be
added to the lambda-lift package in the future.


lambda-lift should only be used to describe actually trivial lambdas,
usually no more than 3 lines long, and should not be used in code
returned by macros, because of "capture" issues. In particular, due to
the LIFT macro's parsing model, it's not safe to nest multiple
invocations.

However, these are not practical limitations since as LIFT expressions
get bigger, the benefits of conciseness quickly fade out to be
replaced by the problems of implicitness, so hopefully one wouldn't be
tempted to use it in these scenarios anyway. The implicitness is not a
problem for suitably short LIFT expressions since the surrounding
context provides enough contextual information, and explicitly naming
variables would then simply provide redundant information.

LIFT's deliberately simplistic "surface parsing" (and replacement)
strategy is conceptually and implementationally simple and robust, as
opposed to often-brittle "code-walking" where an attempt is made to
take into account the actual semantics of forms and operators, often
necessitating explicit support when new operators are introduced.


This library is in the Public Domain.
See the UNLICENSE file for details.
