<!DOCTYPE html>

<html>

  <head>
    <meta charset="UTF-8" />
    <meta name="author" content="Jean-Philippe Paradis" />
    <link rel="author" href="https://abc.hexstream.xyz/" />
    <link rel="license" href="https://www.hexstreamsoft.com/UNLICENSE" />
    <meta name="description" content="A concise, intuitive and flexible syntax (macro) for trivial lambdas that eschews explicit naming of parameter variables in favor of positional references." />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>positional-lambda | Libraries | HexstreamSoft</title>
    <link href="../../css/global.css" rel="stylesheet" type="text/css" />
    <link href="../libraries.css" rel="stylesheet" type="text/css" />
    <script src="https://global.hexstreamsoft.com/scripts/global.js"></script>
    <script src="../../scripts/global.js"></script>
    <script src="../libraries.js" defer></script>
  </head>

  <body>

    <nav id="top-nav">

      <div class="main">

        <div class="breadcrumbs">
          <a href="../../">HexstreamSoft</a>
          <span class="crumb"><span class="s"> » </span><a href="../">Libraries</a></span>
          <span class="crumb"><span class="s"> » </span><a class="here">positional-lambda</a></span>
        </div>

      </div>

    </nav>

    <main>

      <header id="page-header">
        <h1>positional-lambda</h1>
      </header>

      <div class="tags contains-groups">
        <div class="group prominent">
          <span class="tag hv license">
            <span class="h">License<span>:</span></span>
            <span class="v">Public Domain</span>
          </span>
          <span class="s">, </span>
          <span class="tag github"><a href="http://github.com/Hexstream/positional-lambda">See on GitHub</a></span>
          <span class="s">, </span>
          <span class="tag hv quicklisp">
            <span class="h">Load it with Quicklisp<span>:</span></span>
            <code class="v">(ql:quickload "positional-lambda")</code>
          </span>
        </div>
        <div class="group">
          <span class="tag hv">
            <span class="h">Library type<span>:</span></span>
            <span class="v">Concision macro</span>
          </span>
          <span class="s">, </span>
          <span class="tag hv">
            <span class="h">Project complexity<span>:</span></span>
            <span class="v">Simple</span>
          </span>
        </div>
      </div>

      <nav class="tabs" id="further-info">
        <ul>
          <li><a href="../releases/latest-versions/#positional-lambda">Latest release</a></li>
          <li><a href="../dependencies/#positional-lambda">Dependencies</a></li>
        </ul>
        <ul>
          <li><a href="../external-pages-xref/#positional-lambda">External library pages</a></li>
        </ul>
      </nav>

      <section id="introduction">

        <p><dfn><code class="common-lisp library macro operator">plambda</code></dfn> is a concise, intuitive and flexible syntax (macro) for trivial <code class="common-lisp standard macro operator"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a></code>s that eschews explicit (and often contextually-redundant) naming of parameter variables in favor of positional references, with support for a used or ignored <code class="common-lisp standard lambda-list-keyword"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_da.htm#AMrest">&amp;rest</a></code> parameter and automatic declaration of <code class="common-lisp standard declaration"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/d_ignore.htm">ignore</a></code>d parameters when logical "gaps" are left in the positional references. Further convenience features are provided.</p>

      </section>

      <div class="notice note">
        <b>ℹ</b>
        <div>
          <p>
            The project is called "positional-lambda".
            <br />
            The macro itself is called "plambda", for brevity.
          </p>
          <p>This is an exception to my usual policy against abbrevations.</p>
        </div>
      </div>

      <section id="documentation">

        <div class="scroll">

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_values.htm">values</a> <code class="common-lisp library local marker">:3</code> <code class="common-lisp library local marker">:1</code>))
==
(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a> (<var>first</var> <var>second</var> <var>third</var>)
  (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_declar.htm">declare</a> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/d_ignore.htm">ignore</a> <var>second</var>))
  (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_values.htm">values</a> <var>third</var> <var>first</var>))</code></pre>

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_list_.htm">list</a> <code class="common-lisp library local marker">:2</code> <code class="common-lisp library local marker">:1</code> <code class="common-lisp library local marker">:rest</code>))
==
(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a> (<var>first</var> <var>second</var> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_da.htm#AMrest">&amp;rest</a> <var>rest</var>)
  (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_list_.htm">list</a> <var>second</var> <var>first</var> <var>rest</var>))</code></pre>

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> <code class="common-lisp library local marker">:rest</code> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_list_.htm">list</a> <code class="common-lisp library local marker">:2</code> <code class="common-lisp library local marker">:1</code>))
==
(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a> (<var>first</var> <var>second</var> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_da.htm#AMrest">&amp;rest</a> <var>rest</var>)
  (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_declar.htm">declare</a> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/d_ignore.htm">ignore</a> <var>rest</var>))
  (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_list_.htm">list</a> <var>second</var> <var>first</var>))</code></pre>

      </div>

        <p>It's possible to specify a minimum number of required arguments:</p>

        <div class="scroll">

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> <code class="common-lisp library local marker">:3</code> <code class="common-lisp library local marker">:2</code>)
==
(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a> (<var>first</var> <var>second</var> <var>third</var>)
  (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_declar.htm">declare</a> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/d_ignore.htm">ignore</a> <var>first</var> <var>third</var>))
  <var>second</var>)</code></pre>

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> <code class="common-lisp library local marker">:2</code> <code class="common-lisp library local marker">:3</code>) <span class="comment"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/02_dd.htm">;</a> redundant minimum: 3 > 2.</span>
==
(<code class="common-lisp library operator">plambda</code> <code class="common-lisp library local marker">:3</code>)</code></pre>

        </div>

        <p>Which also has the effect of "pushing back" the <code class="common-lisp standard lambda-list-keyword"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_da.htm#AMrest">&amp;rest</a></code> argument if there's one:</p>

        <div class="scroll">

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> <code class="common-lisp library local marker">:3</code> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm">mapcar</a> <code class="common-lisp library local marker">:1</code> <code class="common-lisp library local marker">:rest</code>))
==
(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a> (<var>first</var> <var>second</var> <var>third</var> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_da.htm#AMrest">&amp;rest</a> <var>rest</var>)
  (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_declar.htm">declare</a> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/d_ignore.htm">ignore</a> <var>second</var> <var>third</var>))
  (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mapc_.htm">mapcar</a> <var>first</var> <var>rest</var>))</code></pre>

        </div>

        <p>The first argument to <code class="common-lisp library operator">plambda</code> is treated as a specification of the minimum number of arguments only if it looks like a positional reference and <code class="common-lisp library operator">plambda</code> was invoked with other arguments:</p>

        <div class="scroll">

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> <code class="common-lisp library local marker">:2</code>)
==
(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a> (<var>first</var> <var>second</var>)
  (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_declar.htm">declare</a> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/d_ignore.htm">ignore</a> <var>first</var>))
  <var>second</var>)</code></pre>

        </div>

        <p><code class="common-lisp library operator">plambda</code> accepts an implicit <code class="common-lisp standard special-operator operator"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_progn.htm">progn</a></code>, not just one expression:</p>

        <div class="scroll">

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_wr_pr.htm">print</a> <code class="common-lisp library local marker">:1</code>) <code class="common-lisp library local marker">:2</code>)
==
(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a> (<var>first</var> <var>second</var>)
  (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_wr_pr.htm">print</a> <var>first</var>)
  <var>second</var>)</code></pre>

        </div>

        <p>Also, <code class="common-lisp library operator">plambda</code>'s <code class="common-lisp library local special-operator operator">:let</code> "local special operator" allows one to "lift" parts of its body outside the <code class="common-lisp standard macro operator"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a></code> to a <code class="common-lisp standard special-operator operator"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_let_l.htm">let</a></code> without needing to name and then refer to an explicit variable.</p>

        <div class="scroll">

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> <code class="common-lisp library local marker">:2</code> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_list_.htm">list</a> <code class="common-lisp library local marker">:1</code> (<code class="common-lisp library local special-operator operator">:let</code> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_random.htm">random</a>))))
==
(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_let_l.htm">let</a> ((<var>number</var> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_random.htm">random</a>)))
  (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a> (<var>first</var> <var>second</var>)
    (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_declar.htm">declare</a> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/d_ignore.htm">ignore</a> <var>second</var>))
    (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_list_.htm">list</a> <var>first</var> <var>number</var>)))</code></pre>

        </div>

        <p>Another feature is <code class="common-lisp library local special-operator operator">:cache</code>, which is like <code class="common-lisp library local special-operator operator">:let</code> except it computes the associated form in its original lexical and dynamic context within the <code class="common-lisp standard macro operator"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a></code> the first time its evaluation completes and returns the cached value on subsequent evaluations.</p>

        <div class="scroll">

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_wr_pr.htm">write</a> <code class="common-lisp library local marker">:1</code> :base (<code class="common-lisp library local special-operator operator">:cache</code> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v_pr_bas.htm">*print-base*</a>)))
==
(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_let_l.htm">let</a> (<var>base</var> <var>basep</var>)
  (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a> (<var>first</var>)
    (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_wr_pr.htm">write</a> <var>first</var> :base (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_if.htm">if</a> <var>basep</var>
                           <var>base</var>
                           (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_prog1c.htm">prog1</a> (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_setf_.htm">setf</a> <var>base</var> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v_pr_bas.htm">*print-base*</a>)
                             (<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_setf_.htm">setf</a> <var>basep</var> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v_t.htm">t</a>))))))</code></pre>

        </div>

        <p>The consequences are undefined if the <code class="common-lisp library local special-operator operator">:let</code> and <code class="common-lisp library local special-operator operator">:cache</code> local special operators are nested within themselves or eachother:</p>

        <div class="scroll">

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> (<code class="common-lisp library local special-operator operator">:let</code> (<code class="common-lisp library local special-operator operator">:let</code> 1))) <span class="comment"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/02_dd.htm">;</a> undefined</span></code></pre>

        </div>

        <p><code class="common-lisp library operator">plambda</code> will treat any quoted expressions as opaque, and will treat anything wrapped in the <code class="common-lisp library local special-operator operator">:quote</code> local-special-operator as opaque as well.</p>


        <div class="scroll">

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/02_dc.htm">'</a>:1)
==
(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a> () <a href="http://www.lispworks.com/documentation/HyperSpec/Body/02_dc.htm">'</a>:1)</code></pre>

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> () (<code class="common-lisp library local special-operator operator">:quote</code> :1))
==
(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a> () :1)</code></pre>

        </div>

        <p>Unfortunately, currently <code class="common-lisp library operator">plambda</code> won't do the right thing with some expressions that are quoted via backquote (since there's no easy portable way to walk backquoted expressions).</p>

        <div class="scroll">

          <pre class="example"><code class="common-lisp">(<code class="common-lisp library operator">plambda</code> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/02_df.htm">`</a>(<code class="common-lisp library local marker">:1</code> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/02_dg.htm">,</a><code class="common-lisp library local marker">:2</code>))
==
&lbrack;<code class="common-lisp library local marker">:1</code> will be erroneously replaced&rbrack;</code></pre>

        </div>

        <p>To use <code class="common-lisp library macro operator">plambda</code>, simply <code class="common-lisp">(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defpkg.htm">:import-from</a> #:positional-lambda #:plambda)</code> from your <code class="common-lisp standard macro operator"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defpkg.htm">defpackage</a></code>. Don't <code class="common-lisp">(<a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defpkg.htm">:use</a>)</code>! "Clashy" symbols might be added to the <code class="common-lisp library package">positional-lambda</code> package in the future.</p>

        <p>positional-lambda should only be used to describe actually trivial <code class="common-lisp standard macro operator"><a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_lambda.htm">lambda</a></code>s, <strong>usually no more than 3 lines long</strong>, and should not be used in code returned by macros, because of "capture" issues. <del>In particular, due to the <code class="common-lisp library operator">plambda</code> macro's parsing model, it's not safe to nest multiple invocations.</del> <ins>(Actually, nesting multiple <code class="common-lisp library operator">plambda</code> invocations has been safe for quite a while. The outer invocations will effectively treat any inner ones as being implicitly wrapped in <code class="common-lisp library local special-operator operator">:quote</code>.)</ins></p>

        <p>However, these are not practical limitations since as <code class="common-lisp library operator">plambda</code>'s expressions get bigger, the benefits of conciseness quickly fade out to be replaced by the problems of implicitness, so hopefully one wouldn't be tempted to use it in these scenarios anyway. The implicitness is not a problem for suitably short <code class="common-lisp library operator">plambda</code> expressions since the surrounding context provides enough contextual information, and explicitly naming variables would then simply provide redundant information.</p>

        <p><code class="common-lisp library operator">plambda</code>'s deliberately simplistic "surface parsing" (and replacement) strategy is conceptually and implementationally simple and robust, as opposed to often-brittle "code-walking" where an attempt is made to take into account the actual semantics of forms and operators, often necessitating explicit support when new operators are introduced.</p>

      </section>

    </main>

    <footer id="footer">
      <div class="back-to-top left">
        <a href="#">⬆</a>
      </div>
      <div class="main">
        <a href="http://validator.w3.org/check?uri=http%3A%2F%2Fwww.hexstreamsoft.com%2Flibraries%2Fpositional-lambda%2F">✔ HTML5</a>
        <a href="https://www.hexstreamsoft.com/README">✔ Public Domain</a>
        <a href="http://jigsaw.w3.org/css-validator/validator?uri=http%3A%2F%2Fwww.hexstreamsoft.com%2Flibraries%2Fpositional-lambda%2F">✔ CSS3</a>
        <a>✔ Mobile-friendly</a>
      </div>
      <div class="back-to-top right">
        <a href="#">⬆</a>
      </div>
    </footer>

  </body>
</html>
